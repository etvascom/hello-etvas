# Etvas App

An Etvas App is an application (both Back and Front End) that can run inside an `iframe` fully integrated in the Etvas Customer Portal. It **must** be hosted on a `HTTPS` URL, so the Etvas Customer Portal can load it.

Each product listed in Customer Portal has the URL of the Etvas App configured as a property. When the End Customer uses the product (after the purchase process is successfully finished), the Etvas App is loaded from the specified URL.

## Security

The communication between Etvas App and Etvas Platform has to include two elements:

- A token (shareable), stored in the Front-End Etvas App
- A secret API KEY (non-shareable), stored exclusively in the Back-End Etvas App
- A context, for correct customer and product or service isolation

#### The token

The token is received in the query when the Customer Portal loads the application. You can easily verify the token with our dedicated REST endpoint. The verification also gives the opportunity to extract useful information from the token. Although the token is a standard JWT token, we do not recommend decoding and use information comprised, because it may be subject to change without prior notice.

Please remember the token is valid for one hour.

#### The API Key

The API key is generated by Etvas Platform for each Service Partner and must not be used by the Front-End Etvas App. It should be typically stored in an environment variable for the sole use of Back-End Etvas App. We will provide you with an API KEY.

Please consider the API key as a master password for your account with Etvas. Anyone who can read it can make API calls to Etvas Platform in your name.

If you lose you API key, we will issue another one as fast as possible. In the worst case scenario, when your API key is compromised, you have to contact us immediately to issue a new one. Once a new API key is issued for your account, the old one cannot be used anymore. In any of these cases, you must update your environment variables with the new API key. As we expect downtime in the communication between Etvas and your endpoints, a good timing is crucial to minimize this negative impact.

The API key must be present in all your calls to Etvas platform, as a header named `x-api-key`. Our security infrastructure will validate the request as a first-layer operation.

#### The context

You can obtain the context by verifying the token. Once the validity of the token (expiry and signature) is verified, you will receive as response an object containing a `context`. You can use the received context to various calls, including getting the customer profile.

> **Note**: Each time a customer uses your product or service, a new shiny fresh token will be generated. When verifying the token, you receive a context. You should be aware of the fact that, for the same customer and the same product/service, the context will always be the same, even though the token is different.

## Data flow

> Note: if you are using [etvas-sdk](https://github.com/etvascom/etvas-sdk), everything is simpler. Please consult the [documentation](https://github.com/etvascom/etvas-sdk).

The common data flow is:

#### First,

The customer purchases your product, using the payment gateway embedded in Etvas Platform. When and if the payment finish with a success code, an `product.purchased` event is sent to your pre-defined URL. More info [here](#events).

The Etvas Application (or Etvas App) is launched in an `iframe` with a generated **token** present in the query, when the user clicks on `Use product` button.

The Etvas App communicates the token to it's BackEnd, which `POST`s it at the `/verify-token` endpoint, decorating the request with the appropriate header for the API key.

It resembles something like this:

```
HTTP/1.1 POST https://api.etvas.com/verify-token
Content-Type: application/json
Accept: application/json
x-api-key: your-api-key-here

{
  "token": "received-token-here"
}
```

The success response is:

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "contextId": "context-is-uuid-36-chars-long-string",
  ...
}
```

You should always _always_ **always** verify the received token.

#### Second,

You can use the context to get the customer profile:

```
HTTP/1.1 GET https://api.etvas.com/user/profile
Accept: application/json
x-api-key: your-api-key-here
x-etvas-context: context-is-uuid-36-chars-long-string

--
HTTP/1.1 200 OK
Content-Type: application/json

{
  "firstName": "The customer's first name",
  "lastName": "The customer's last name",
  "email": "customer@etvas.com",
  "phoneNumber": "+1234345456"
}
```

#### Third,

You should create the resources in your back-end to accommodate this new customer.

At this step, if you need additional resources, you can use the UI of the Etvas App to ask for more information from the user and process them. From here on, you have the full control over the data and customer flow. You can implement all the logic in Etvas App (the preferred way) or redirect the user to your web application.

In the latter case, you **must** use a mechanism to automatically and secure login the customer. Double login has a very heavy negative impact on User Experience and the Etvas Policy forbids such behaviors.

Bear in mind, by using the Etvas App UI (which uses the `npm` package [etvas-kit](https://github.com/etvascom/etvas-kit)), you can take advantage of an unified UI, the custom theme embedded in each customer portal and the implementation of the **I18N** multi-language, meaning when a customer sets up his or hers profile in German, everything is translated into German, even the Etvas App. All of these are made and ready for you to use.

## Events

Various events needs to be communicated by Etvas Platform to Etvas App. We present below a list with the events you can choose to receive, configured in your platform account.

> Note: if you are using [etvas-sdk](https://github.com/etvascom/etvas-sdk), everything is simpler. Please consult the [documentation](<(https://github.com/etvascom/etvas-sdk)>).

All events are `POST` requests made to the pre-defined URL you specify in your platform account. They all have the following signature:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "event.name",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

> Note: You should always use the contextId (which resembles a purchaseId) and not the productId. The same customer can buy more than once the same product, resulting in a repeated `productId` but a different `contextId`.

> **Warning** The response you return matter. If you return a `200 OK` or a `204 No Content` response, the event will be marked and logged as successful. If you return a `30X Redirect`, the platform will follow up to 5 redirects. If there are more, the response will be considered a failure. Anything in the range `4XX` or `5XX` will also be considered a failure.

#### Product purchased

This event is emitted when the purchase is successful and the customer's card is successfully charged in Etvas Platform. After this event is processed successfully, the customer should be able to fully access the bought product/service.

The `name` of this event is `product.purchased`:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "product.purchased",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

This event is formal, meaning you can control the outcome based on the HTTP status you return. If you respond with a success HTTP status, the product is marked as purchased and the user can use it. If not (a HTTP status of `4xx` or `5xx`), the product will be marked as Failed Purchase and the matter must be resolved by human support intervention. Needless to say, nobody wants this situation.

#### Product canceled

This event is emitted in two situations: when the customer chooses to cancel his subscription OR when a specific time-based subscription reaches it's end-of-time moment.

After processing this event, the customer should not be able to access the canceled product or services.

The `name` of this event is `product.canceled`:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "product.canceled",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

This event is informal, meaning your response to the request will be logged, but you cannot control the outcome by returning a certain HTTP status.

#### Product suspended

This event is emitted when a subsequent (subscription based) payment cound not be charged to the customer credit or debit card.

After processing this event, the customer should not be able to access the suspended product or services.

The `name` of this event is `product.suspended`:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "product.suspended",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

This event is informal, meaning your response to the request will be logged, but you cannot control the outcome by returning a certain HTTP status.

Also, the outcome of this event is reversible by the `product.repurchased` event.

#### Product repurchased (resumed)

This event is emitted when a suspended product is resolved: the customer updated the payment method in his/hers account and the payment went through with a success status.

After processing this event, the customer should be able to access the resumed product or services, without any data loss due to purchase suspended operation.

The `name` of this event is `product.repurchased`:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "product.repurchased",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

This event is informal, meaning your response to the request will be logged, but you cannot control the outcome by returning a certain HTTP status.

Also, the outcome of this event is reversible by the `product.suspended` event.

#### User deleted

This event is emitted when a user chooses to delete his/hers account. Please consult the GDPR resources available regarding the personal information that must be deleted or anonymized.

After processing this event, the customer should not be able to access the resumed product or services, and all the information stored **must** be deleted or anonymized.

The `name` of this event is `user.deleted`:

```
HTTP/1.1 POST /etvas/events
Content-Type: application/json
Accept: application/json
x-api-key: the-api-key

{
  "name": "user.deleted",
  "payload": {
    "productId": "uuid-36-char-long-string",
    "contextId": "uuid-36-char-long-string"
  }
}
```

This event is informal, meaning your response to the request will be logged, but you cannot control the outcome by returning a certain HTTP status.

## Using Etvas Platform for storing and retrieving information

> Note: if you are using [etvas-sdk](https://github.com/etvascom/etvas-sdk), everything is simpler. Please consult the [documentation](https://github.com/etvascom/etvas-sdk).

You have at your disposal a very fast, key-value storage offered by Etvas Platform. You can store a string value of max **100K**.

Typically you use the `context` as key but you can use anything you like, as long as it's a string. You have three operations at your fingertips: read, write and clear.

The **read** operation is, of course, a `GET` request:

```
HTTP/1.1 GET /external-data/key-index
Accept: application/json
x-api-key: your-provided-api-key

--
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data": "your-previously-stored-data"
}
```

> **Note:** the query will not be failing if no data is stored, but simply return a null value in `data` attribute.

A **write** operation is - don't get ahead of me - a `POST` operation :)

```
HTTP/1.1 POST /external-data/key-index
Content-Type: application/json
x-api-key: your-provided-api-key

{
  "data": "a string you want to store, it can easily be a JSON encoded object"
}

--
HTTP/1.1 200 OK
```

If you choose to send JSON encoded objects (which might be the primary use), please take into account the maximum **100K** bytes for the _resulting_ JSON.

If you use Base 64 encoding (i.e. for binary data), you have to multiply the byte size by approx. 1.6 (which is the approximate increase in length when you use this encoding).

You can **clear** the stored data in two ways: storing a `null` value in a _write_ operation or calling the following delete method:

```
HTTP/1.1 DELETE /external-data/key-index
x-api-key: your-provided-api-key

--
HTTP/1.1 200 OK
```

**OR**

```
HTTP/1.1 POST /external-data/key-index
Content-Type: application/json
x-api-key: your-provided-api-key

{
  "data": null
}

--
HTTP/1.1 200 OK
```
